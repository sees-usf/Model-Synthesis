from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from ordered_set import OrderedSet
from py4j.java_gateway import JavaGateway
from matplotlib.backends.backend_pdf import PdfPages
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

from ortools.sat.python import cp_model

#Class defined for printing a limited amount of solutions
class VarArraySolutionPrinterWithLimit(cp_model.CpSolverSolutionCallback):
    """Print intermediate solutions."""

    def __init__(self, variables):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self.__variables = variables

    def isRedundantSolution(self, test):

        if not solutions:
            return False

        for solution in solutions:
            if test.issubset(solution):
                return True
            elif test.issuperset(solution):
                solutions.remove(solution)
                return False

        return False

    #This function is called at the end of a solution being generated by the CSPSolver
    #All edges with support of 0 are skipped and not printed.
    #Keep the self.generateGraph() commented out for now because it does display
    #the visuals correctly
    def on_solution_callback(self):

        test = OrderedSet([])

        for v in self.__variables:
            if self.Value(v) != 0:
                test.add(v)

        isSubset = self.isRedundantSolution(test)

        lastStoredChar = 'a'

        constraintsToBeAdded = []

        for v in test :

            if str(lastStoredChar) != str(v)[0] :
                lastStoredChar = str(v)[0]
                listOfConstraintsToBeAdded.append(constraintsToBeAdded)
                constraintsToBeAdded = []
            
            #Constraint generation for edges that have support > 0
            #Added to a list to be used as a BoolOr linear constraint
            #to help avoid finding redundant solutions

            b = 'b' + str(v)
            for i in boolVars:
                if str(i) == b:
                    constraintsToBeAdded.append(i)
                    break
        
        listOfConstraintsToBeAdded.append(constraintsToBeAdded)

        if not isSubset:
            solutions.append(test);

        self.StopSearch()

    def solution_count(self):
        return self.__solution_count

    #This function generates a Graph visualization using NetworkX and stores the visual
    #in a pdf file. This still needs work, as it prints the graphs in an unreadable format
    def generateGraph(self):
        plt.figure(self.__solution_count)
        plt.title("Solution %i" % self.__solution_count)
        fromList = []
        toList = []
        edgeWeights = []
        
        for v in self.__variables:
            edgeFound = False
            if self.Value(v) != 0:
                for i in range(nodes.size()):
                    if edgeFound:
                        edgeFound = False
                        break
                    fromNode = str(nodes.get(i).getSymbolIndex())
                    for j in range(nodes.size()):
                        if not edgeFound:
                            toNode = str(nodes.get(j).getSymbolIndex())
                            edgeID = 'x' + fromNode + '_' + toNode
                            targetID = str('%s' % v)
                            if edgeID == targetID:
                                fromList.append(fromNode)
                                toList.append(toNode)
                                edgeWeights.append(self.Value(v))
                                edgeFound= True
                                break

        df = pd.DataFrame({ 'from': fromList, 'to' : toList, 'support' : edgeWeights })
        G = nx.from_pandas_edgelist(df, source='from', target='to', edge_attr='support', create_using=nx.DiGraph())
        #NEED TO UPDATE GRAPHIC LAYOUT
        for row, data in nx.shortest_path_length(G):
            for col, dist in data.items():
                df.loc[row,col] = dist + 1000
        df = df.fillna(df.max().max())
        pos = nx.kamada_kawai_layout(G, dist = df.to_dict())
        nx.draw(G, pos, with_labels=True, node_size=600, alpha=1.0, arrows = True)
        labels = nx.get_edge_attributes(G, 'support')
        nx.draw_networkx_edge_labels(G, pos, labels)
        #pdf.savefig()
        plt.close()
        
#This function prepares the variables and constraints necessary to run a CSPSolver
#on an annotated acyclic dependency graph
def SearchForAllSolutionsSampleSat():
    """Minimal CP-SAT example to showcase calling the solver."""
    # Creates the model.

    model = cp_model.CpModel()

    charID = 'a'
    listOfEdgeVars = []
    listOfNodeVars = []

    for dag in dags:

        nodes = dag.getNodes()
        edgeVars = []
        nodeVars = []

        #This loop prepares node variables, edge variables, and also all constraints related to the outgoing edges of each node i
        for i, origin in enumerate(nodes) : 
            #maxSupport = graph.getNode(origin.getSymbolIndex()).getSupport()
            #nodeIntVar = model.NewIntVar(0 , maxSupport, charID + str(origin.getSymbolIndex()))
            nodeIntVar = model.NewIntVar(0 , origin.getSupport(), charID + str(origin.getSymbolIndex()))
            nodeVars.append(nodeIntVar)
            edges = origin.getEdges()
            col = []

            if edges.size() != 0 :
                for j, edge in enumerate(edges):
                    #edge = edges.get(j)
                    #edgeSupport = graph.getEdge(edge.getSource().getSymbolIndex(), edge.getDestination().getSymbolIndex()).getEdgeSupport()
                    edgeSupport = edge.getEdgeSupport()
                    intId = charID + str(edge.getId())
                    boolId = 'b' + intId
                    edgeIntVar = model.NewIntVar(0, edgeSupport, intId)
                    edgeBoolVar = model.NewBoolVar(boolId)
                    model.Add(edgeIntVar == 0).OnlyEnforceIf(edgeBoolVar)
                    col.append(edgeIntVar)
                    boolVars.append(edgeBoolVar)

            edgeVars.append(col)
            
            sumIntVars = 0
            if len(edgeVars[i]) != 0 :
                for j in range(len(edgeVars[i])) :
                    sumIntVars += edgeVars[i][j]
                model.Add(nodeVars[i] == sumIntVars)
        
        #This loop prepares constraints for every node i that has incoming edges
        for i, destination in enumerate(nodes) :
            sumIntVars = 0

            for j, origin in enumerate(nodes) :

                if origin == destination :
                    continue

                edgeID = str(origin.getSymbolIndex()) + '_' + str(destination.getSymbolIndex())
                edges = origin.getEdges()

                if edges.isEmpty() :
                    continue

                for k, edge in enumerate(edges) :
                    if edgeID == edge.getId() :
                        #edgeSupport = graph.getEdge(edge.getSource().getSymbolIndex(), edge.getDestination().getSymbolIndex()).getEdgeSupport()
                        edgeSupport = edge.getEdgeSupport()
                        if edgeSupport != 0 :
                            sumIntVars += edgeVars[j][k] #The sum of all incoming edges to the node at j
            
            if sumIntVars != 0 :
                model.Add(nodeVars[i] == sumIntVars)

        charID = chr(ord(charID)+1)
        listOfEdgeVars.append(edgeVars)
        listOfNodeVars.append(nodeVars)
    
    #print('Additional constraints created for DAGs, identical nodes across DAGs must have supports that sum up to the total node support of original graph\'s node')
    for node in graph.getNodes():
        
        if graph.getRoots().contains(node):
            continue

        sumIntVars = 0

        for nodeVars in listOfNodeVars :
            for nodeVar in nodeVars :
                if node.getSymbolIndex() in str(nodeVar) :
                    if node.getSymbolIndex() != str(nodeVar)[1:] :
                        continue
                    sumIntVars += nodeVar
        model.Add(sumIntVars == node.getSupport())
        #print()
        #print(str(sumIntVars) + ' == ' + str(node.getSupport()))
    
    #print()
    finalEdges = []

    #Convert 2D array of constraints to 1D for CSPSolver

    for edgeVars in listOfEdgeVars :
        for i in range(len(edgeVars)) :
            for j in range(len(edgeVars[i])) :
                finalEdges.append(edgeVars[i][j])

    solver = cp_model.CpSolver()
    solutionPrinter = VarArraySolutionPrinterWithLimit(finalEdges)
    status = solver.SearchForAllSolutions(model, solutionPrinter)

    #Call solver until status is infeasible, every iteration adds constraints
    #based on the edges contained in the prior solution that had supports > 0
    while solver.StatusName(status) != 'INFEASIBLE' :

        for constraintsToBeAdded in listOfConstraintsToBeAdded :
            model.AddBoolOr(constraintsToBeAdded)

        listOfConstraintsToBeAdded.clear()
        solutionPrinter = VarArraySolutionPrinterWithLimit(finalEdges)
        status = solver.SearchForAllSolutions(model, solutionPrinter)
    
    #lastStoredChar = 'a'
    #dagSolutions = []

    #print(solutions)

    '''
    for solution in solutions:
        dagSolution = OrderedSet([])
        for v in solution:
            if str(lastStoredChar) != str(v)[0] :
                lastStoredChar = str(v)[0]
                dagSolutions.append(dagSolution)
                dagSolution = OrderedSet([])
            dagSolution.add(v)
        dagSolutions.append(dagSolution)

    solutions.clear()

    lastStoredChar = 'a'
    dagSolution = OrderedSet([])

    #Work on this!!!
    
    for solution in dagSolutions:
        for otherSolution in dagSolutions:
            if solution == otherSolution:
                continue
            if solution.issuperset(otherSolution) and solution.issuperset(dagSolution):
                dagSolution = solution
            if str(lastStoredChar) != str(v)[0] :
                lastStoredChar = str(v)[0]
                solutions.append(dagSolution)
                dagSolution = OrderedSet([])
        solutions.append(dagSolution)
    '''
    
    currCount = 0
    lastStoredChar = 'a'
    
    for solution in solutions:
        currCount += 1
        print('Solution %i' % currCount)
        for v in solution:
            if str(lastStoredChar) != str(v)[0] :
                lastStoredChar = str(v)[0]
                print()
            print(str(v))
        print()

    print('Number of solutions found: %i' % currCount)

#Creates a pdf for writing
#pdf = PdfPages('results.pdf')

#Connects to GatewayServer running in Main.java
gateway = JavaGateway()

print('This is CSPSolver.py')
print()
print('Each trace is identified by its own integer value (1, 2, so on)')
print()
print('Following the processing of solutions for a given trace, a status will display to show if ')
print('the solutions found were OPTIMAL, FEASABLE, INFEASABLE, MODEL-INVALID, or UNKNOWN along with the number of solutions found.')
print('When a trace is beginning to be analyzed, the program will notify you which trace has begun analysis.')
print('When a trace is done being analyzed, this will be displayed at the end of each status.')
print()
print('Every solution will be printed with each edge ID followed by its support value.')
print('All solutions will omit any edges with 0 support to simplify the result')
#print('You will be asked if you would like these solutions to be printed, or if you would like to see')
#print('the solution status and the number of solutions found only.')
#print()
#print('Warning: CSPSolver may take a long time to process solutions for a given trace. If this is the case, it is')
#print('recommended that you set a limit to the number of solutions found when prompted')
#print()

limit = 0 #input('Please enter how many solutions you would like to print for each trace (Enter 0 for unlimited): ')
print()
solutionsCanPrint = 'y' #input('Please specify if you would like each solution to be printed (enter y or n): ')
print()
print('The definition file being used is ' + str(gateway.entry_point.getDefFileName()))
print('The trace file being used is ' + str(gateway.entry_point.getTraceFileName()))
print()
print('CSPSolver is now running')
print()

count = 1
boolVars = []
listOfConstraintsToBeAdded = []
solutions = []

#Run each trace through the CSP solver until there are no more left in stack
while bool(gateway.entry_point.hasTraces()) :
    print('Analyzing Trace ' + str(count) + ' Solutions\n')
    gateway.entry_point.annotateGraph()
    graph = gateway.entry_point.getGraph()
    graph.printGraph();
    nodes = graph.getNodes()
    dags = gateway.entry_point.getAnnotatedDAGS()
    SearchForAllSolutionsSampleSat()
    graph.resetGraphSupport()
    print()
    print('End of Trace ' + str(count) + ' Solutions\n')
    count += 1
    gateway.entry_point.popTrace()
    
print()
print('All traces have been analyzed. Please re-run Main.java to perform experiments again.')

#pdf.close()
#plt.show()
#multipage('test')           





